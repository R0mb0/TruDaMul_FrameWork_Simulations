------------------------------  ------------------------------
--        **  **        --
--  <<>>  

-- TruDaMul Framwork base implementation with base properties to check.

------------------------------ Begin Main ------------------------------
MODULE main

VAR

-- 1,2 are two variables used to distinguish the two different mules   
c  : client( m1, m2);
m1 : mule(1, c, p); 
m2 : mule(2, c, p);
p  : proxy(m1, m2, s);
s  : server(p);

--        ** Properties to Check **        --
 
-- reachability  property FALSE
CTLSPEC
EF(c.wallet < 0)
-- reachability  property TRUE
CTLSPEC
EF(m1.wallet = 50 & m2.wallet = 0)
-- liveness property FALSE
CTLSPEC
AG(c.state = request -> AF(c.state = according))
-- liveness property FALSE
CTLSPEC
AG(p.state = waitingMule -> AF(p.state = according))

------------------------------ End Main------------------------------

------------------------------ Begin Client ------------------------------
MODULE client(id, m1, m2, safety)

VAR

-- state null       : No message to send.
-- state request    : Request to send a message. 
-- state according  : Arranging with the mule for the price of the mule work.
-- state waiting    : Message delivered to the mule. Wait for the answer. 
-- state response   : The mule have just deliver me the answer. 
-- state payment    : Paying the mule for his work. 

state  : {null, request, according, waiting, response, payment};

--  <<Variable Wallet contains the Tokens that the client can spends to by Mule jobs (initialized with n tokens).>>
wallet : 0..50;  

--  <<Variable Choice contains the chosen mule id. >> 
choice : 0..2;

safety : boolean;


ASSIGN

init(state)  := null;
next(state)  :=
    case
        wallet = 0 : null;
        -- The client can have a message to send or not.
        state = null : {null, request};
        -- At least one mule is in the client's position.
        (state = request) & (m1.Position = client | m2.Position = client) : according;
        (safety = TRUE) & (state = according) : waiting;
        (safety = FALSE) & (state = according) & (m1.id = choise)
          : (m1.decision = accept) ? waiting : request;
        (safety = FALSE) & (state = according) & (m2.id = choise)
          : (m2.decision = accept) ? waiting : request;    
        (state = waiting) & (m1.message = lost | m2.message = lost) : request;    
        -- The client received the response from the server.
        (state = waiting) & (m1.state = goingToC & m1.Position = client) : response; 
        (state = waiting) & (m2.state = goingToC & m2.Position = client) : response;
        -- Message sent to proxy.
        (state = waiting ) & ((m1.state = deliverToP) | (m2.state = deliverToP)) : payment;  
        state  = response : payment; 
        -- Mule hired to deliver the message.
        (state = payment) & (m1.state = wait & m1.Position = proxy) : waiting;   
        (state = payment) & (m2.state = wait & m2.Position = proxy) : waiting;  
        -- Mule payed to delivering the answer
        (state = payment) & (m1.state = wait & m2.Position = client) : null;
        (state = payment) & (m1.state = wait & m2.Position = client) : null;
        TRUE : state;
    esac;

init(wallet) := 50;
next(wallet) :=
    case
        -- Given 1 token to the mule that has completed the job.
        (wallet > 0) & (state  = payment) : wallet - 1;
        wallet = 0 : 0;
        TRUE : wallet;
    esac;

init(choice) := 0;
next(choice) :=
    case
        -- Client has to send a message but both mules aren't in his zone.
        (state = request) & (m1.Position != client) & (m2.Position != client) : 0;
        -- Client has to send a message and only m1 is in his position.
        (state = request) & (m1.Position  = client) & (m1.blacklist = FALSE) 
        & (m2.Position != client) : 1;
        (state = request) & (m1.Position  = client) & (m1.blacklist = TRUE)
        & (m2.Position != client) : {0,1};       
        -- Client has to send a message and only m2 is in his position.
        (state = request) & (m1.Position != client) & (m2.Position  = client) 
        & (m2.blacklist = FALSE) : 2;
		(state = request) & (m1.Position != client) & (m2.Position = client) 
		& (m2.blacklist = TRUE)  : {0,2};               
        -- Client has to send a message and both mules are in his zone. The choice is non-deterministic. 
        (state = request) & (m1.Position  = client) & (m2.Position  = client)
        & (m1.blacklist = FALSE) & (m2.blacklist = TRUE) : 1;
        (state = request) & (m1.Position  = client) & (m2.Position  = client)
        & (m1.blacklist = TRUE) & (m2.blacklist = FALSE) : 2;
        (state = request) & (m1.Position  = client) & (m2.Position  = client)
        & (m1.blacklist = FALSE) & (m2.blacklist = FALSE) : {1,2};
        (state = request) & (m1.Position  = client) & (m2.Position  = client)
        & (m1.blacklist = TRUE) & (m2.blacklist = TRUE) : {0,1,2};        
        -- the job is done. 
        (m1.message = lost) | (m2.message = lost) : 0;
        (state = payment) : 0;
        TRUE : choice;
    esac;

init(safety) := {TRUE, FALSE};
next(safety) :=
    case
    	-- ogni volta che il client sta pagando, il valore safety cambia
		(state = payment) : {TRUE, FALSE};
        TRUE : safety;
    esac;
    


------------------------------ End Client ------------------------------

------------------------------ Begin Mule ------------------------------

MODULE mule(id, c, p)

VAR

-- state walking     : Walking randomly waiting for a work. 
-- state talkingToC  : Arranging with the client. 
-- state talkingToP  : Arranging with the proxy.
-- state goingToP    : Travelling to deliver the message to proxy.
-- state goingToC    : Travelling to deliver the response to client.
-- state deliverToP  : Delivering the message to proxy.
-- state deliverToC  : Delivering the response to client.
-- state wait        : Waiting to get paid.

state      : {walking, talkingToC, talkingToP, goingToP, goingToC, deliverToC, deliverToP, wait};

--  <<Mule positions during the walk.>>  
Position : {client, proxy, middle};

--  <<Mule wallet (initialized with 0 tokens).>>  
wallet : 0..50;

message : {null, lost, owned};

blacklist : boolean;

decision : {null, accept, refuse};

ASSIGN

init(state) := walking;
next(state) :=
    case
        -- The client has a message to send.
        (state = walking) & (Position = client) & (c.state = request)     : talkingToC;
        -- The proxy has a response to send.
        (state = walking) & (Position = proxy)  & (p.state = waitingMule) : talkingToP;
        -- Assignment of the job to mule. 
        (state = talkingToC) & (c.choice  = id)  : goingToP;
        (state = talkingToC) & (c.choice != id)  : walking;
        (state = talkingToP) & (p.choice  = id)  : goingToC;
        (state = talkingToP) & (p.choice != id)  : walking;
        (message = lost) : walking
        -- Going to proxy.
        (message = owned) & (state = goingToP) & (Position = client) : goingToP;
        (message = owned) & (state = goingToP) & (Position = middle) : goingToP;
        (message = owned) & (state = goingToP) & (Position = proxy)  : deliverToP;
        -- Going to client.
        (message = owned) & (state = goingToC) & (Position = proxy)  : goingToC;
        (message = owned) & (state = goingToC) & (Position = middle) : goingToC;
        (message = owned) & (state = goingToC) & (Position = client) : deliverToC;
        -- Requesting to get paid.
        (state = deliverToP) | (state = deliverToC) : wait;
        -- Job Terminated.
        (state = wait)    : walking;
        TRUE : state;
    esac;

-- At the beginning the position is chosen non-deterministically. 
init(Position) := {client, proxy, middle};
next(Position) :=
    case
        -- Walking randomly waiting for a job.
        (state = walking)  & (Position = client) & (c.state != request) : {client, middle};
        (state = talkingToC) & (c.choise != id) : middle;
        (state = walking)  & (Position = middle) : {client, middle, proxy};
        (state = walking)  & (Position = proxy)  & (p.state != waitingMule) : {proxy, middle};
        -- Going to proxy.
        (state = goingToP) & (Position = client) : middle;
        (state = goingToP) & (Position = middle) : proxy;
        -- Going to client.
        (state = goingToC) & (Position = proxy)  : middle;
        (state = goingToC) & (Position = middle) : client;
     
        TRUE : Position;
    esac;

init(wallet) := 0;
next(wallet) :=
    case
    	(wallet = 50)  : 50;
        -- Earned a token for have completed the job.
        (c.state = payment) : wallet + 1;
        TRUE : wallet;
    esac;

init(message) := null;
next(message) :=
    case
    	-- il client mi ha affidato il lavoro.
    	(message = lost) : null;
		(state = talkingToC) & (c.choise = id) & (decision = accept) : owned;
		(state = talkingToC) & (c.choise = id) & (decision = refuse) : null;
		(c.safety = TRUE)  & (state = goingToP) & (Position = client) : owned;
		(c.safety = FALSE) & (state = goingToP) & (Position = client) : {lost, owned};	
		(message = owned) & (state = goingToP) & (Position = middle) : {lost, owned};
		(state = deliverToP)  : null;
		(state = talkingToP) & (p.choise = id) : owned;
		message = owned) & (state = goingToC) & (Position = middle) : {lost, owned};
        (c.safety = TRUE)  & (state = goingToC) & (Position = client) : owned;
		(c.safety = FALSE) & (state = goingToC) & (Position = client) : {lost, owned};						
		(state = deliverToC) : null;	
        TRUE : message;
    esac;
    
init(blacklist) := FALSE;
next(blacklist) :=
    case
		-- perdo il messaggio, vado nella blacklist
		(message = lost) : TRUE;
		-- il proxy ha ricevuto correttamente il messaggio
		(p.state = message) | (c.state = responce) : TRUE;
        TRUE : blacklist;
    esac;

init(decision) := null;
next(decision) :=
    case
    	(Position = client) & (c.state = request) & (c.safety = TRUE)  : accept;
    	(Position = client) & (c.state = request) & (c.safety = FALSE) : {refuse, accept};
    	(message = lost) : null
    	(state = talkingToC) & (c.choise != id) : null
		(state = DeliverToP) : null;
        TRUE : decision;
    esac;

------------------------------ End Mule ------------------------------

------------------------------ Begin Proxy ------------------------------
MODULE proxy(m1, m2, s)

VAR

-- state null        : Waiting for a message. 
-- state message     : A mule just handed a message. 
-- state forward     : Forwarding the message to the server. 
-- state wait        : Waiting to recive the server response to deliver.
-- state response    : The server just handed a response.
-- state waitingMule : Waiting for a mule to deliver the serever response.
-- state according   : Arranging with the mule to deliver the answer.

state  : {null, message, forward, wait, response, waitingMule, according};
  
--  <<Id of the mule that has been hired for the job.>>  
choice : 0..2;

ASSIGN

init(state) := null;
next(state) :=
    case
        -- Received the message.
        (state = null) & (m1.state = goingToP & m1.Position = proxy) : message;
        (state = null) & (m2.state = goingToP & m2.Position = proxy) : message;
        (state = message) : forward;
        (state = forward) : wait;
        (state = wait)    : response;
        (state = response) : waitingMule;
        -- Waiting to deliver the response to a mule.
        (state = waitingMule) & (m1.Position != proxy & m2.Position != proxy) : waitingMule;
        (state = waitingMule) & (m1.Position  = proxy | m2.Position  = proxy) : according;
        -- Returning to waiting for a message.
        (state = according) : null;  
        (m1.state = goingToC & m1.message = lost) : waitingMule;
        (m2.state = goingToC & m2.message = lost) : waitingMule;        
        TRUE : state;
    esac;

init(choice) := 0;
next(choice) :=
    case
        -- Waiting to send a response but both mules aren't in his zone.
        (state = waitingMule) & (m1.Position != proxy) & (m2.Position != proxy) : 0;
        -- Waiting to send a response to mule 1.
        (state = waitingMule) & (m1.Position  = proxy) & (m2.Position != proxy) : 1;
        -- Waiting to send a response to mule 2.
        (state = waitingMule) & (m1.Position != proxy) & (m2.Position  = proxy) : 2;
        -- Waiting to send a response but both mules are in zone. The assignment choice is non-deterministic.
        (state = waitingMule) & (m1.Position  = proxy) & (m2.Position  = proxy) : {1,2};
        (m1.message = lost) | (m2.message : lost) : 0; 
        (m1.state = wait) | (m2.state = wait) : 0;
        TRUE : choice;
    esac;

------------------------------ End Proxy ------------------------------

------------------------------ Begin Server ------------------------------

MODULE server(p)

VAR

-- state null     : Suspended.
-- state message  : The proxy just delivered the client message. 
-- state make     : Making the response.
-- state forward  : Forwarding the message to proxy.

state : {null, message, make , forward};

ASSIGN

init(state) := null;
next(state) :=
    case
        -- Received proxy's message.
        (state = null) & (p.state = message) : message;
        -- Making a response.
        state = message : make;
        -- Forwarding the response.
        state = make    : forward;
        -- returning to suspended state.
        state = forward : null;
        TRUE : state;
    esac;

------------------------------ End Server ------------------------------

