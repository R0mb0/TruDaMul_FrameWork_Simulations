-- TruDaMul Framwork base implementation with base properties to check.

------------------------------ Begin Main ------------------------------
MODULE main

VAR

-- 1,2 are two variables used to distinguish the two different mules   
c  : client(m1, m2);
m1 : mule(1, c, p); 
m2 : mule(2, c, p);
p  : proxy(m1, m2, s);
s  : server(p);

--        ** Properties to Check **        --
 
-- reachability  property, the client doesn't reach a state where the wallet value is < 0 | FALSE
CTLSPEC
EF(c.wallet < 0)

-- reachability  property, there is a state where m1 has performed all the jobs | TRUE
CTLSPEC
EF(m1.wallet = 50 & m2.wallet = 0)

-- liveness property, the client's request may go unheard | FALSE
CTLSPEC
AG(c.state = request -> AF(c.state = according))

-- liveness property, the proxy's request may go unheard | FALSE
CTLSPEC
AG(p.state = waitingMule -> AF(p.state = according))

------------------------------ End Main------------------------------

------------------------------ Begin Client ------------------------------
MODULE client(m1, m2)

VAR

-- state null       : No message to send.
-- state request    : Request to send a message. 
-- state according  : Arranging with the mule for the price of the mule work.
-- state waiting    : Message delivered to the mule. Wait for the answer. 
-- state response   : The mule have just deliver me the answer. 
-- state payment    : Paying the mule for his work. 

state  : {null, request, according, waiting, response, payment};

--  <<Variable Wallet contains the Tokens that the client can spends to by Mule jobs (initialized with n tokens).>>
wallet : 0..50;  

--  <<Variable Choice contains the chosen mule id.>> 
choice : 0..2;

ASSIGN

init(state)  := null;
next(state)  :=
    case
        wallet = 0 : null;
        -- The client can have a message to send or not.
        state = null : {null, request};
        -- At least one mule is in the client's position.
        (state = request) & (m1.Position = client | m2.Position = client) : according;
        state = according : waiting;
        -- The client received the response from the server.
        (state = waiting) & (m1.state = goingToC & m1.Position = client) : response; 
        (state = waiting) & (m2.state = goingToC & m2.Position = client) : response;
        -- Message sent to proxy.
        (state = waiting ) & ((m1.state = deliverToP) | (m2.state = deliverToP)) : payment;  
        state  = response : payment; 
        (state = payment) : waiting;
        -- Mule hired to deliver the message.
        (state = payment) & (m1.state = wait & m1.Position = proxy) : waiting;   
        (state = payment) & (m2.state = wait & m2.Position = proxy) : waiting;  
        -- Mule payed to delivering the ansewer
        (state = payment) & (m1.state = wait & m2.Position = client) : null;
        (state = payment) & (m1.state = wait & m2.Position = client) : null;
        TRUE : state;
    esac;

init(wallet) := 50;
next(wallet) :=
    case
        -- Given 1 token to the mule that has completed the job.
        (wallet > 0) & (state  = payment) : wallet - 1;
        wallet = 0 : 0;
        TRUE : wallet;
    esac;

init(choice) := 0;
next(choice) :=
    case
        -- Client has to send a message but both mules aren't in his zone.
        (state = request) & (m1.Position != client) & (m2.Position != client) : 0;
        -- Client has to send a message and only m1 is in his position.
        (state = request) & (m1.Position = client) & (m2.Position != client) : 1;
        -- Client has to send a message and only m2 is in his position.
        (state = request) & (m1.Position != client) & (m2.Position = client) : 2;
        -- Client has to send a message and both mules are in his zone. The choice is non-deterministic. 
        (state = request) & (m1.Position = client) & (m2.Position = client) : {1,2};
        -- the job is done. 
        (state = payment) : 0;
        TRUE : choice;
    esac;

------------------------------ End Client ------------------------------

------------------------------ Begin Mule ------------------------------

MODULE mule(id, c, p)

VAR

-- state walking     : Walking randomly waiting for a work. 
-- state talkingToC  : Arranging with the client. 
-- state talkingToP  : Arranging with the proxy.
-- state goingToP    : Travelling to deliver the message to proxy.
-- state goingToC    : Travelling to deliver the response to client.
-- state deliverToP  : Delivering the message to proxy.
-- state deliverToC  : Delivering the response to client.
-- state wait        : Waiting to get paid.

state      : {walking, talkingToC, talkingToP, goingToP, goingToC, deliverToC, deliverToP, wait};

--  <<Mule positions during the walk.>>  
Position : {client, proxy, middle};

--  <<Mule wallet (initialized with 0 tokens).>>  
wallet : 0..50;

ASSIGN

init(state) := walking;
next(state) :=
    case
        -- The client has a message to send.
        (state = walking) & (Position = client) & (c.state = request)     : talkingToC;
        -- The proxy has a response to send.
        (state = walking) & (Position = proxy)  & (p.state = waitingMule) : talkingToP;
        -- Assignment of the job to mule. 
        (state = talkingToC) & (c.choice = id)  : goingToP;
        (state = talkingToC) & (c.choice != id)  : walking;
        (state = talkingToP) & (p.choice = id)  : goingToC;
        (state = talkingToP) & (p.choice != id)  : walking;
        -- Going to proxy.
        (state = goingToP) & (Position = client) : goingToP;
        (state = goingToP) & (Position = middle) : goingToP;
        (state = goingToP) & (Position = proxy)  : deliverToP;
        -- Going to client.
        (state = goingToC) & (Position = proxy)  : goingToP;
        (state = goingToC) & (Position = middle) : goingToP;
        (state = goingToC) & (Position = client) : deliverToC;
        -- Requesting to get paid.
        (state = deliverToP) | (state = deliverToC) : wait;
        -- Job Terminated.
        (state = wait)    : walking;
        TRUE : state;
    esac;

-- At the beginning the position is chosen non-deterministically. 
init(Position) := {client, proxy, middle};
next(Position) :=
    case
        -- Walking randomly waiting for a job.
        (state = walking)  & (Position = client) & (c.state != request) : {client, middle};
        (state = walking)  & (Position = middle) : {client, middle, proxy};
        (state = walking)  & (Position = proxy)  & (p.state != waitingMule) : {proxy, middle};
        -- Going to proxy.
        (state = goingToP) & (Position = client) : middle;
        (state = goingToP) & (Position = middle) : proxy;
        -- Going to client.
        (state = goingToC) & (Position = proxy)  : middle;
        (state = goingToC) & (Position = middle) : client;
        TRUE : Position;
    esac;

init(wallet) := 0;
next(wallet) :=
    case
    	(wallet = 50)  : 50;
        -- Earned a token for have completed the job.
        (state = wait) : wallet + 1;
        TRUE : wallet;
    esac;

------------------------------ End Mule ------------------------------

------------------------------ Begin Proxy ------------------------------
MODULE proxy(m1, m2, s)

VAR

-- state null        : Waiting for a message. 
-- state message     : A mule just handed a message. 
-- state forward     : Forwarding the message to the server. 
-- state wait        : Waiting to recive the server response to deliver.
-- state response    : The server just handed a response.
-- state waitingMule : Waiting for a mule to deliver the serever response.
-- state according   : Arranging with the mule to deliver the answer.

state  : {null, message, forward, wait, response, waitingMule, according};
  
--  <<Id of the mule that has been hired for the job.>>  
choice : 0..2;

ASSIGN

init(state) := null;
next(state) :=
    case
        -- Received the message.
        (state = null) & (m1.state = goingToP & m1.Position = proxy) : message;
        (state = null) & (m2.state = goingToP & m2.Position = proxy) : message;
        (state = message) : forward;
        (state = forward) : wait;
        (state = wait)    : response;
        (state = response) : waitingMule;
        -- Waiting to deliver the response to a mule.
        (state = waitingMule) & (m1.Position != proxy & m2.Position != proxy) : waitingMule;
        (state = waitingMule) & (m1.Position = proxy | m2.Position = proxy) : according;
        -- Returning to waiting for a message.
        (state = according) : null;  
        TRUE : state;
    esac;

init(choice) := 0;
next(choice) :=
    case
        -- Waiting to send a response but both mules aren't in his zone.
        (state = waitingMule) & (m1.Position != proxy) & (m2.Position != proxy) : 0;
        -- Waiting to send a response to mule 1.
        (state = waitingMule) & (m1.Position = proxy) & (m2.Position != proxy) : 1;
        -- Waiting to send a response to mule 2.
        (state = waitingMule) & (m1.Position != proxy) & (m2.Position = proxy) : 2;
        -- Waiting to send a response but both mules are in zone. The assignment choice is non-deterministic.
        (state = waitingMule) & (m1.Position = proxy) & (m2.Position = proxy) : {1,2}; 
        (m1.state = wait) | (m2.state = wait) : 0;
        TRUE : choice;
    esac;

------------------------------ End Proxy ------------------------------

------------------------------ Begin Server ------------------------------

MODULE server(p)

VAR

-- state null     : Suspended.
-- state message  : The proxy just delivered the client message. 
-- state make     : Making the response.
-- state forward  : Forwarding the message to proxy.

state : {null, message, make , forward};

ASSIGN

init(state) := null;
next(state) :=
    case
        -- Recived proxy's message.
        (state = null) & (p.state = message) : message;
        -- Making a response.
        state = message : make;
        -- Forwaring the response.
        state = make    : forward;
        -- returning to suspended state.
        state = forward : null;
        TRUE : state;
    esac;

------------------------------ End Server ------------------------------

