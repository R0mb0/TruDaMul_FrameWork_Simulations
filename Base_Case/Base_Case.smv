-- Progetto d'esame Linguaggi di programmazione e verifica del software
-- TruDaMul: a Trusted Framework for Smart Territories based on Untrusted Data Mules

------------------------------------------------
MODULE main

VAR

c  : client(m1, m2);
m1 : mule(1, c, p);
m2 : mule(2, c, p);
p  : proxy(m1, m2, s);
s  : server(p);

---------- Proprietà da verificare -------------

------------------------------------------------

MODULE client(m1, m2)

VAR

-- stato null              : non ho nessun messaggio da inviare.
-- stato request           : mi metto in attesa di un mulo per inviare un messaggio.
-- stato_according_to_mule : mi sto organizzando con il mulo per consegnargli il messaggio.
-- stato waiting           : messaggio consegnato al mulo, mi metto in attesa della risposta.
-- stato responce_received : il mulo mi ha appena consegnato la risposta.
-- stato payment           : pago il mulo per il suo servizio.

state   : {null, request, according_to_mule, waiting, responce_received, payment};

wallet  : 0...50;  

ASSIGN

init(state)  := null;
next(state)  :=
    case
        ------------
        TRUE : state;
    esac;

init(wallet) := 50;
next(wallet) :=
    case
        ------------
        TRUE : wallet;
    esac;
------------------------------------------------

MODULE mule(id, c, p)

VAR

-- stato walking            : sto camminando in modo casuale, non mi è stato assegnato nessun compito.
-- stato talking_to_client  : il client mi sta consegnando un messaggio. 
-- stato talking_to_proxy   : il proxy mi sta consegnando una risposta.
-- stato going_to_proxy     : sono in viaggio per consegnare il messaggio al proxy.
-- stato going_to_client    : sono in viaggio per consegnare la risposta al client.
-- stato deliver            : sto consegnando il messaggio al proxy o la risposta al client.
-- stato waiting_for_reward : sto aspettando di essere pagato.

state         : {walking, talking_to_client, talking_to_proxy, going_to_proxy, going_to_client, deliver, waiting_for_reward};

-- range in cui si trova il mulo.
my_position   : {client, proxy, middle};


ASSIGN

init(state) := walking;
next(state) :=
    case
        -----------
        TRUE : state;
    esac;

init(my_position) := {client, proxy, middle};
next(my_position) :=
    case
        -----------
        TRUE : my_range;
    esac;

------------------------------------------------

MODULE proxy(m1, m2, s)

VAR

-- stato null              : sono sospeso.
-- stato messagge_received : il mulo mi ha appena consegnato un messaggio.
-- stato forward           : sto inoltrando il messaggio al server.
-- stato waiting           : sto aspettando che il server mi consegni la risposta.
-- stato responce_received : il server mi ha appena consegnato una risposta.
-- stato waiting_for_mule  : mi metto in attesa del mulo per affidargli la risposta.
-- stato_according_to_mule : mi sto organizzando con il mulo per consegnargli la risposta.

state : {null, message_received, forward, waiting, responce_received, waiting_for_mule, according_to_mule};

ASSIGN

init(state) := null;
next(state) :=
    case
        ----------
    esac;

------------------------------------------------


MODULE server(p)

VAR

-- stato null              : sono sospeso.
-- stato messagge_received : il proxy mi ha appena consegnato il messaggio.
-- stato making_responce   : sto preparando la risposta.
-- stato forward           : inoltro la risposta al proxy.

state : {null, messagge_received, making_responce, forward};

ASSIGN

init(state) := null;
next(state) :=
    case

    esac;


